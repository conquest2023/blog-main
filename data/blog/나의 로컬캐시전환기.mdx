---
title: 'Redis는 만능이 아니다 — 나의 로컬 캐시 전환기'
date: '2025-11-03'
tags: ['CS', 'Java', 'Infra']
draft: false
summary: '이번 글에서는 로컬캐시 전환기에 대해 설명할 예정입니다'
---

도서관 프로젝트를 진행하면서 정적인 데이터는 Redis에 데이터를 무조건 넣어야한다고 판단을 했습니다. 

당시 그렇게 생각한 이유는 두 가지였습니다.

#### 1.  Redis 를 사용했던 이유

1\. 어차피 Redis를 이미 사용하기로 했으니, 정적 데이터도 Redis에 저장하면 통합적으로 관리할 수 있을 것이라 생각했습니다.

2.도서관 데이터는 자주 변경되지 않는 정적인 정보였고, 쿠버네티스 환경에서 여러 파드가 동시에 구동되다 보니, 데이터 정합성을 유지하려면 중앙 캐시(=Redis)가 더 적합하다고 판단했습니다.

> 하지만 실제로 운영을 해보니, “이 데이터가 정말 Redis에 있을 필요가 있을까?” 라는 의문이 들기 시작했습니다.

제가 사용하던 데이터의 특징을 설명하겠습니다.

#### 2.  데이터 특징

| 항목        | 설명                                         |
| ----------- | -------------------------------------------- |
| 데이터 종류 | 전국 도서관 정보 (API 호출 결과)             |
| 데이터 크기 | 작음( 10000건이하)                           |
| 변경 주기   | 매우 느림 (일주일 단위~평생 안바뀔수도 있음) |
| 접근 패턴   | read-only / 서버 시작 시 초기화 형태         |
| 일관성 요구 | 낮음 (조금 차이나도 문제 없음)               |

위와 같은 데이터 특성을 고려했을 떄, 굳이 Redis를 사용해야 할 **명확한 이유를 찾지 못했습니다.**

이 데이터는 변경 주기가 매우 느리고, 일관성 요구 수준도 낮기 때문에 각 파드가 로컬 캐시를 통해 데이터를 들고 있어도 큰 문제가 없다고 판단했습니다.

**오히려 모든 파드가 동일한 Redis 서버로부터 같은 데이터를 읽는 구조**는 불필요한 네트워크 hop을 만들고, Redis 연결 및 관리에 따른 운영 비용을 증가시킬 수 있다고 느꼈습니다.

> 그래서 ‘이런 정적 데이터를 굳이 중앙 캐시에 둘 필요가 있을까?’라는 의문이 들었고, 그때부터 로컬 캐시로의 전환을 검토하기 시작했습니다.

#### 3.  로컬 캐시 전환

실제 구현에서는 Java의 로컬 캐시 라이브러리인 **CaffeineCacheManager**를 사용했습니다.

```
@Bean
public CacheManager cacheManager() {
    CaffeineCacheManager manager = new CaffeineCacheManager("libraries");
    manager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(10_000)
            .expireAfterWrite(Duration.ofHours(24)));
    return manager;
}
```

물론 단순히 ConcurrentHashMap을 사용해서 직접 캐시를 구현할 수도 있었지만, 저는 **CaffeineCacheManager**를 선택했습니다.

그 이유는 두 가지입니다.

1.  **TTL(만료 시간)을 설정할 수 있다.**  
    → 데이터 갱신 주기에 맞춰 캐시를 자동으로 갱신할 수 있습니다.
2.  **ConcurrentHashMap보다 훨씬 높은 성능과 풍부한 기능을 제공한다.**  
    → 내부적으로 LRU(Least Recently Used) 정책, hit/miss 통계, eviction 전략 등을 지원해 직접 구현 대비 효율적이고 안정적입니다.

따라서 단순한 로컬 Map 캐시보다 **더 안정적이고 효율적인 로컬 캐시 관리가 가능**하다고 판단을 했습니다.

#### 4\. 성능 측정

Redis와 로컬 캐시의 성능 차이를 직접 확인하기 위해, 실제 서비스 로직 일부(가장 가까운 도서관 조회 로직)에 캐시를 적용한 뒤

동일한 조건에서 테스트를 진행했습니다.

#### 4.1) 환경

OS : Ubuntu24.04

HardWare: Ser7 7840

네트워크 환경: 동일 서버 내부 환경(Redis 포함)

테스트 방식:  "가장 가까운 도서관" API 로직에 캐시를 삽입하여 1회 측정 수행(공공 API 호출 제한 10000건/일로 인해 단회 측정)

측정 항목: 평균 응답 시간(ms)

동일한 로직(가장 가까운 도서관 조회)에 대해 Redis 캐시와 로컬 캐시를 각각 적용하여 평균 응답 속도를 측정했습니다.

#### 4.2) 측정 결과

| **구분**                 | 평균 응답 시간 (ms)  | 비고                            |
| ------------------------ | -------------------- | ------------------------------- |
| **로컬 캐시 (Caffeine)** | 1,730                | 메모리 직접 접근                |
| **Redis 캐시**           | 2,045                | 네트워크 + 직렬화 오버헤드 포함 |

결과적으로 로컬 캐시가 약 **15.4% 빠른 응답 속도**를 보였습니다.

Redis를 사용할 경우 캐시 데이터 자체는 동일했지만, 매 요청마다 Redis 서버와의 네트워크 통신 및 직렬화/역직렬화 과정에서 추가적인 지연이 발생했습니다.

반면 로컬 캐시는 **애플리케이션 메모리 내에서 즉시 접근**이 가능해 요청 처리 속도가 더 짧게 측정되었습니다.

#### 5\. 얻은 이점

Redis 대신 로컬 캐시를 적용하면서 다음과 같은 개선 효과를 얻을 수 있었습니다.

1\. 성능 

Redis를 사용하지 않고 로컬캐시를 이용하니 네트워크 비용이 없어 API 응답속도가 15% 개선 되었습니다.

2\. 안정성

Redis 장애가 발생하더라도 로컬 캐시는 독립적으로 동작하기 때문에 외부 인프라 의존성이 줄었습니다.

3\. 관리

별도의 인프라 구성이나 연결 관리가 필요하지않아 유연성이 높아졌습니다.

하지만 꼭 로컬캐시를 사용한다고 무조건 장점만 있는것은 아닙니다.

#### 6\. 단점

1\. 메모리 사용량 증가

노드마다 중복 데이터를 저장하기떄문에 서버 자원 낭비가 발생할 수 있습니다.

2\. 스케일 아웃 시 초기 로딩

새 파드를 띄울시 캐시가 초기화되어, warm-up 과정에서 일시적으로 응답 속도가 느려질 수 있습니다.

이런 Redis와 로컬 캐시의 Trade Off 가 있으므로 문제 상황에 따라 적절하게 선택하는 것이 중요합니다.

#### 7\. Redis가 필요한 경우

제가 생각했을 때, **Redis를 사용해야 하는 대표적인 상황**은 다음과 같습니다.  
즉, 단순한 속도 문제가 아니라 “데이터 공유·일관성·확장성”이 중요한 경우입니다.

1\. 여러 인스턴스가 **동일 데이터를 즉시 공유해야 할 때**

로컬 캐시는 애플리케이션 인스턴스(파드)마다 독립적인 캐시를 가지고 있습니다.  
따라서 한 인스턴스에서 캐시가 갱신되어도, 다른 인스턴스는 그 변경을 즉시 반영받지 못합니다.

ex) 로그인 세션 정보 , 실시간 재고 수량 , 랭킹 좋아요

2\. 데이터 일관성이 **중요하거나 빈번히 변경될 때**

도서관 정보처럼 **정적 데이터(read-only)** 는 로컬 캐시가 유리하지만,

로그인 상태, 알림 읽음 여부, 실시간 통계처럼 **변경이 잦은 데이터**는 로컬 캐시로 처리할 경우 동기화 문제로 이어질 수 있습니다.

3. **분산 락(distributed lock)**, 큐 관리 기능이 필요할 경우

Redis는 단순 캐시를 넘어서 여러 고급 기능을 제공합니다.

- 분산 락(Distributed Lock)
- 메시지 큐(Pub/Sub)
- TTL 기반 자동 만료 관리
- Sorted Set 기반 랭킹 처리 등

이러한 기능들은 단순 로컬 캐시에서는 구현하기 어렵거나, 직접 구현하려면 오버헤드가 큽니다.

7-1) 정리

| **구분**             | 로컬 캐시             | Redis                    |
| -------------------- | --------------------- | ------------------------ |
| **데이터 접근 속도** | 매우 빠름 (in-memory) | 빠름 (네트워크 hop 존재) |
| **데이터 일관성**    | 인스턴스별 독립       | 중앙 집중형, 일관성 유지 |
| **변경 빈도**        | 낮은 정적 데이터 적합 | 높은 갱신 빈도에 적합    |
| **확장성**           | 단일 인스턴스 기준    | 다중 인스턴스 공유 용이  |
| **관리 부담**        | 거의 없음             | 별도 인프라/운영 필요    |

Redis와 로컬 캐시를 직접 비교해보면서,  
“무조건 Redis가 답은 아니다”라는 걸 확실히 느꼈습니다.

결국 어떤 캐시를 선택하느냐는 **데이터의 특성과 시스템 구조**에 달려 있다고 생각합니다.

여기까지 읽어주셔서 감사합니다!
