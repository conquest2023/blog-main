---
title: '락(Lock)이란?'
date: '2025-10-27'
tags: ['CS', 'OS', 'DB']
draft: false
summary: '이번 글에서는 Lock에 대해 설명할 예정입니다'
---

이번에 프로젝트를 하는 도중에 사용자가 동시에 쓰기 작업을 할 경우 데이터의 정합성(Consistency)이 어긋난다고 판단을 하여 락에 대해 공부하려 합니다.

### 1\. Lock

락(Lock)의 개념은 비단 데이터베이스에만 국한되지 않습니다.

**운영체제(OS)의 커널 단**에서 여러 프로세스가 공유 자원에 접근할 때 발생하는 경쟁 조건을 막기 위해 뮤텍스(Mutex)나 세마포어(Semaphore)와 같은 동기화 도구가 필수적입니다.

> 뮤텍스(Mutex)는 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 하나의 Process 혹은 Thread가 접근하는 것을 막아주는 것을 뜻합니다.

> 세마포어(Semaphore)는 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 여러 Process 혹은 Thread가 접근해주는 것을 막아주는것을 뜻합니다.

또한, **애플리케이션 코드 단**에서도 자바의 synchronized 키워드나 명시적인 ReentrantLock 등을 사용하여 임계 영역(Critical Section)을 보호해야 합니다.

> synchronized 는 특정 **객체(Object)의 모니터 락(Monitor Lock)** 을 획득해야 블록 안에 진입 가능합니다.

> ReentrantLock은 간단하고 안전하지만, **세밀한 제어(공정성, 타임아웃, 시도적 락 등)** 가 불가능한 **자동 락 입니다.**

이러한 **경쟁 조건(Race Condition)** 을 막기 위해 DB는 내부적으로 “락(Lock)”을 사용합니다.  
락은 말 그대로 “데이터를 잠그는 장치”로, 동시에 접근하는 트랜잭션이 서로 간섭하지 못하도록 순서를 조정해 줍니다.

RDBMS는 내부적으로 다양한 종류의 락 모드를 가지고 있습니다.  
하지만 저는 그중에서도 가장 기본이자 핵심이 되는 **공유 락(Shared Lock)** 과 **배타 락(Exclusive Lock)** 을 중심으로 정리해보려 합니다.

## 2\. 공유락과 베타락

### 2-1) 베타 락(Exclusive Lock)

특정 행(Row)에 쓰기 작업이 진행 중일 때, 다른 트랜잭션이 해당 행을 **읽거나 수정하지 못하도록 완전히 차단**하는 락입니다.

#### 베타 락(Exclusive Lock)의 특징

- 데이터를 **수정(쓰기)** 하기 위해 걸어두는 락
- 공유락도 안됨
  - 락을 건 트랜잭션 **본인만** 해당 데이터를 읽고 쓸 수 있음
    - 다른 트랜잭션은 **읽기(Read)도 불가능**
    - **쓰기 작업 중에는 아무도 접근 불가**
  - for update 구문 사용

베타락 예시

> 예를 들어 트랜잭션 A가 게시글 ID=1에 대해 SELECT ... FOR UPDATE를 수행했다면, 트랜잭션 B는 해당 게시글을 조회하려 해도 대기 상태로 들어갑니다. 락이 해제되기 전까지는 접근이 불가능합니다.  
> MySQL InnoDB 기준으로는 이 락이 Row-level Exclusive Lock으로 걸리며, 트랜잭션이 커밋되거나 롤백될 때 자동으로 해제됩니다.

### 2-2)공유 락(Shared Lock)

공유 락(Shared Lock)은 데이터를 읽기만 할 때 사용되는 락입니다.

단순 조회만 한다면 **공유락(Shared Lock)** 을 걸어 여러 트랜잭션이 동시에 읽을 수는 있지만,  
누군가 배타락을 걸려고 하면 그 순간부터 대기하게 됩니다.

- 특정 값을 읽을 때, 그 값을 아무도 변경하지 못하도록 하고 싶음
- 여러 트랜잭션이 동시에 공유 락을 걸 수 있음 (읽기만 가능하니까 충돌 없음)
  - 동시에 같은 행에 공유 락을 걸 수 있음
    - 하지만 **배타 락은 못 걸게 막음** (읽고 있는데 누가 쓰면 안 되니까)

공유 락 예시

> 예를 들어 게시글 조회 API가 동시에 여러 번 호출되어도 모든 트랜잭션이 Shared Lock을 얻을 수 있습니다.  
> 하지만 그중 하나라도 수정(UPDATE)을 시도하면, Shared Lock이 모두 해제될 때까지 대기해야 합니다.

### 2-3) 데드 락(Deadlock)

서로 다른 트랜잭션이 **서로가 가진 락을 기다리며** 무한 대기 상태에 빠지는 것을 뜻합니다.

- **예시:**
  - 트랜잭션 A: Row 1에 락 → Row 2를 기다림
  - 트랜잭션 B: Row 2에 락 → Row 1을 기다림  
    → **서로 락을 기다리다 둘 다 멈춰버림 = 데드락 발생**

두 트랜잭션이 서로 상대방이 가진 락을 기다리면 교착 상태(Deadlock)가 발생합니다.  
DB는 보통 이런 상황을 감지하면 **한쪽 트랜잭션을 강제로 롤백시켜** 시스템이 멈추지 않게 합니다.  
즉, 데드락은 피할 수 없는 현상이지만 “최소화”되도록 쿼리 순서를 통일하고 락 범위를 작게 유지하는 게 중요합니다.

이러한 공유락과 배타락은 **데이터베이스 내부에서 트랜잭션 간의 충돌을 제어하는 수준의 락**입니다.  
하지만 애플리케이션 코드 단에서도 여러 스레드가 동시에 공유 자원에 접근할 수 있기 때문에, 별도의 **애플리케이션 레벨 락**이 필요합니다.

### 3\. 애플리케이션 Level Lock

**애플리케이션 레벨에서는 비관적 락 (Pessimistic Lock)** 과 **낙관적 락 (Optimistic Lock)으로 나뉩니다.**

- DB의 락을 **어떻게 쓸지 결정하는 전략**

#### 3-1) 낙관적 락(Optimistic Lock)

트랜잭션이 애초에 충돌이 발생하지 않는다 라고 가정하고 사용하는 전략을 뜻합니다.

낙관적 락(Optimistic Lock) 특징

- 수정할 때 내가 먼저 이 값을 수정했다고 명시(Version을 업데이트)하여 다른 사람이 동일한 조건으로 값을 수정할 수 없게 하는 전략
  - **Version 컬럼**을 이용해 수정 시점을 검증
    - 수정 시 WHERE id = ? AND version = ? 조건으로 업데이트하고, 성공 시 version을 +1 
  - 버전이 맞지 않으면 예외가 발생
- 조회 하면서 Lock을 거는 작업이 필요없어서 성능적으로 우세
  - 낙관적 락은 읽기 작업이 많고 수정이 적은 시스템, 대규모 트랜잭션이 빈번하게 발생하지 않는 환경에서 주로 사용됨.

#### 3-2) 비관적 락(Pessimistic Lock)

트랜잭션이 매번 충돌이 발생한다 라고 가정하고 공유 락이나 베타락을 사용하여 데이터를 미리 잠그는 전략을 뜻합니다.

비관적 락(Pessimistic Lock) 특징

- 트랜잭션이 시작될 때 **해당 행(Row)** 에 락을 걸고 시작
- Reeatable Read 또는 Serializable 정도의 격리성 수준을 제공
- **트랜잭션이 시작될 때 Shared Lock 또는 Exclusive Lock을 걸고 시작하는 방법**
  - 트랜잭션이 락을 해제할 때까지 다른 트랜잭션이 대기해야 하기 때문에 성능 저하가 발생할 수 있음

정리 

|   구분    | 낙관적 락 (Optimistic Lock)               | 비관적 락 (Pessimistic Lock)                |
| --------- | ----------------------------------------- | ------------------------------------------- |
| 철학      | “충돌 거의 없음” → 나중에 확인            | “언제든 충돌 날 수 있다고 판단” → 먼저 잠금 |
| 락 방식   | 락 X → **버전(version) 비교**로 충돌 감지 | **락 O → SELECT 시점에 행 잠금**            |
| 성능      | 충돌 적으면 좋음 (성능 높음)              | 동시성 낮음, 안정성 높음                    |
| 사용 상황 | 읽기 많고, 쓰기 적은 상황                 | 동시에 같은 데이터를 자주 수정할 때         |
| 예시      | 게시글 추천수 업데이트                    | 수강신청, 은행 잔액 변경                    |

하지만 위에서 설명한 모든 락은 **하나의 데이터베이스 트랜잭션 안에서만 유효**합니다.  
서버가 여러 대이거나, 여러 자원이 엮인 분산 환경에서는 이 방식만으로는 부족합니다.  
다음 글에서는 이러한 한계를 해결하기 위한 **Redis 기반 분산 락(Distributed Lock)** 을 자세히 다뤄보겠습니다.
